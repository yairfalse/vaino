package output

import (
	"fmt"
	"reflect"
	"strings"
	"time"

	"github.com/yairfalse/wgo/pkg/types"
)

// MarkdownFormatter handles markdown output formatting
type MarkdownFormatter struct {
	config Config
}

// NewMarkdownFormatter creates a new markdown formatter
func NewMarkdownFormatter(config Config) *MarkdownFormatter {
	return &MarkdownFormatter{config: config}
}

// FormatDriftReport formats a drift report as markdown
func (m *MarkdownFormatter) FormatDriftReport(report *types.DriftReport) ([]byte, error) {
	var md strings.Builder

	md.WriteString("# Drift Report\n\n")
	
	// Report metadata
	md.WriteString("## Summary\n\n")
	md.WriteString(fmt.Sprintf("- **Report ID**: `%s`\n", report.ID))
	md.WriteString(fmt.Sprintf("- **Baseline ID**: `%s`\n", report.BaselineID))
	md.WriteString(fmt.Sprintf("- **Current ID**: `%s`\n", report.CurrentID))
	md.WriteString(fmt.Sprintf("- **Generated**: %s\n", report.Timestamp.Format(m.config.TimeFormat)))
	md.WriteString(fmt.Sprintf("- **Total Changes**: %d\n\n", len(report.Changes)))

	if len(report.Changes) == 0 {
		md.WriteString("## Results\n\n")
		md.WriteString("âœ… **No drift detected** - Infrastructure matches baseline perfectly.\n\n")
	} else {
		md.WriteString("## Changes Detected\n\n")
		md.WriteString(fmt.Sprintf("### All Changes (%d)\n\n", len(report.Changes)))
			
		md.WriteString("| Field | Path | Old Value | New Value | Severity |\n")
		md.WriteString("|-------|------|-----------|-----------|----------|\n")
		
		for _, change := range report.Changes {
			oldVal := m.escapeMarkdown(fmt.Sprintf("%v", change.OldValue))
			newVal := m.escapeMarkdown(fmt.Sprintf("%v", change.NewValue))
			
			// Truncate long values
			if len(oldVal) > 50 {
				oldVal = oldVal[:47] + "..."
			}
			if len(newVal) > 50 {
				newVal = newVal[:47] + "..."
			}
			
			md.WriteString(fmt.Sprintf("| %s | %s | %s | %s | %s |\n",
				change.Field,
				change.Path,
				oldVal,
				newVal,
				change.Severity,
			))
		}
		md.WriteString("\n")
	}

	md.WriteString("---\n")
	md.WriteString(fmt.Sprintf("*Generated by wgo at %s*\n", time.Now().Format(m.config.TimeFormat)))

	return []byte(md.String()), nil
}

// FormatSnapshot formats a snapshot as markdown
func (m *MarkdownFormatter) FormatSnapshot(snapshot *types.Snapshot) ([]byte, error) {
	var md strings.Builder

	md.WriteString("# Infrastructure Snapshot\n\n")
	
	// Snapshot metadata
	md.WriteString("## Summary\n\n")
	md.WriteString(fmt.Sprintf("- **Snapshot ID**: `%s`\n", snapshot.ID))
	md.WriteString(fmt.Sprintf("- **Provider**: %s\n", snapshot.Provider))
	md.WriteString(fmt.Sprintf("- **Captured**: %s\n", snapshot.Timestamp.Format(m.config.TimeFormat)))
	md.WriteString(fmt.Sprintf("- **Total Resources**: %d\n", len(snapshot.Resources)))
	md.WriteString(fmt.Sprintf("- **Collection Time**: %s\n", snapshot.Metadata.CollectionTime))
	md.WriteString(fmt.Sprintf("- **Collector Version**: %s\n\n", snapshot.Metadata.CollectorVersion))

	// Resources by type
	resourcesByType := make(map[string][]types.Resource)
	for _, resource := range snapshot.Resources {
		resourcesByType[resource.Type] = append(resourcesByType[resource.Type], resource)
	}

	md.WriteString("## Resources by Type\n\n")
	for resourceType, resources := range resourcesByType {
		md.WriteString(fmt.Sprintf("### %s (%d)\n\n", resourceType, len(resources)))
		
		md.WriteString("| ID | Name | Region |\n")
		md.WriteString("|----|------|--------|\n")
		
		for _, resource := range resources {
			region := resource.Region
			if region == "" {
				region = "N/A"
			}
			
			md.WriteString(fmt.Sprintf("| `%s` | %s | %s |\n",
				resource.ID,
				resource.Name,
				region,
			))
		}
		md.WriteString("\n")
	}

	return []byte(md.String()), nil
}

// FormatBaseline formats a baseline as markdown
func (m *MarkdownFormatter) FormatBaseline(baseline *types.Baseline) ([]byte, error) {
	var md strings.Builder

	md.WriteString("# Baseline\n\n")
	
	md.WriteString("## Details\n\n")
	md.WriteString(fmt.Sprintf("- **ID**: `%s`\n", baseline.ID))
	md.WriteString(fmt.Sprintf("- **Name**: %s\n", baseline.Name))
	if baseline.Description != "" {
		md.WriteString(fmt.Sprintf("- **Description**: %s\n", baseline.Description))
	}
	md.WriteString(fmt.Sprintf("- **Snapshot ID**: `%s`\n", baseline.SnapshotID))
	md.WriteString(fmt.Sprintf("- **Created**: %s\n", baseline.CreatedAt.Format(m.config.TimeFormat)))
	md.WriteString(fmt.Sprintf("- **Version**: %s\n\n", baseline.Version))

	if len(baseline.Tags) > 0 {
		md.WriteString("## Tags\n\n")
		for key, value := range baseline.Tags {
			md.WriteString(fmt.Sprintf("- **%s**: %s\n", key, value))
		}
		md.WriteString("\n")
	}

	return []byte(md.String()), nil
}

// FormatBaselineList formats a list of baselines as markdown
func (m *MarkdownFormatter) FormatBaselineList(baselines []BaselineListItem) ([]byte, error) {
	if len(baselines) == 0 {
		return []byte("# Baselines\n\nNo baselines found.\n"), nil
	}

	var md strings.Builder
	md.WriteString("# Baselines\n\n")
	
	return m.formatStructListAsMarkdown(baselines, md.String())
}

// FormatSnapshotList formats a list of snapshots as markdown
func (m *MarkdownFormatter) FormatSnapshotList(snapshots []SnapshotListItem) ([]byte, error) {
	if len(snapshots) == 0 {
		return []byte("# Snapshots\n\nNo snapshots found.\n"), nil
	}

	var md strings.Builder
	md.WriteString("# Snapshots\n\n")
	
	return m.formatStructListAsMarkdown(snapshots, md.String())
}

// FormatDriftReportList formats a list of drift reports as markdown
func (m *MarkdownFormatter) FormatDriftReportList(reports []DriftReportListItem) ([]byte, error) {
	if len(reports) == 0 {
		return []byte("# Drift Reports\n\nNo drift reports found.\n"), nil
	}

	var md strings.Builder
	md.WriteString("# Drift Reports\n\n")
	
	return m.formatStructListAsMarkdown(reports, md.String())
}

// formatStructListAsMarkdown formats a slice of structs as a markdown table
func (m *MarkdownFormatter) formatStructListAsMarkdown(items interface{}, prefix string) ([]byte, error) {
	var md strings.Builder
	md.WriteString(prefix)

	v := reflect.ValueOf(items)
	if v.Kind() != reflect.Slice {
		return nil, fmt.Errorf("items must be a slice")
	}

	if v.Len() == 0 {
		md.WriteString("No items found.\n")
		return []byte(md.String()), nil
	}

	// Get the first item to determine structure
	firstItem := v.Index(0)
	itemType := firstItem.Type()

	// Extract headers from struct tags
	var headers []string
	var fieldNames []string
	for i := 0; i < itemType.NumField(); i++ {
		field := itemType.Field(i)
		tableTag := field.Tag.Get("table")
		if tableTag != "" {
			headers = append(headers, tableTag)
			fieldNames = append(fieldNames, field.Name)
		}
	}

	// Write markdown table header
	md.WriteString("| " + strings.Join(headers, " | ") + " |\n")
	md.WriteString("|" + strings.Repeat(" --- |", len(headers)) + "\n")

	// Write rows
	for i := 0; i < v.Len(); i++ {
		item := v.Index(i)
		var row []string
		for _, fieldName := range fieldNames {
			fieldValue := item.FieldByName(fieldName)
			value := m.escapeMarkdown(fmt.Sprintf("%v", fieldValue.Interface()))
			// Truncate long values
			if len(value) > 50 {
				value = value[:47] + "..."
			}
			row = append(row, value)
		}
		md.WriteString("| " + strings.Join(row, " | ") + " |\n")
	}

	return []byte(md.String()), nil
}

// escapeMarkdown escapes special markdown characters
func (m *MarkdownFormatter) escapeMarkdown(s string) string {
	replacements := []string{
		"|", "\\|",
		"*", "\\*",
		"_", "\\_",
		"`", "\\`",
		"#", "\\#",
	}
	
	replacer := strings.NewReplacer(replacements...)
	return replacer.Replace(s)
}